<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STFT — Magnitude & Phase (plus clair)</title>
  <style>
    :root{
      --bg:#f6f7fb; --panel:#fff; --border:rgba(15,23,42,.14);
      --grid:rgba(15,23,42,.08); --text:#0f172a; --muted:rgba(15,23,42,.65);
      --accent:#2563eb;
      --good:#16a34a;
      --warn:#f59e0b;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; padding:14px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg); color:var(--text);
    }
    .wrap{ width:min(1080px, 98vw); margin:0 auto; }
    h1{ margin:0 0 10px; font-size:18px; letter-spacing:.2px; }
    .sub{ margin:-6px 0 10px; color:var(--muted); font-size:13.5px; line-height:1.35; }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 22px rgba(15,23,42,.06);
    }

    .plots{ display:grid; gap:10px; }
    canvas{
      width:100%;
      display:block;
      border:1px solid var(--border);
      border-radius:12px;
      background:linear-gradient(180deg, rgba(15,23,42,.02), transparent);
    }
    #mag{ height:260px; }
    #phs{ height:260px; }
    #phaseLine{ height:240px; }

    .sectionTitle{
      display:flex; align-items:baseline; justify-content:space-between;
      margin:0 0 8px;
      gap:10px;
    }
    .sectionTitle h2{
      margin:0;
      font-size:14px;
      letter-spacing:.2px;
    }
    .pill{
      display:inline-block;
      padding:2px 10px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.14);
      background: rgba(15,23,42,.03);
      color: var(--muted);
      font-size:12.5px;
      white-space:nowrap;
    }

    /* Controls */
    .controls{
      display:grid;
      gap:10px;
    }
    .ctrl{
      border:1px solid rgba(15,23,42,.12);
      background: rgba(15,23,42,.02);
      border-radius:12px;
      padding:10px;
    }
    .ctrlHead{
      display:flex; align-items:baseline; justify-content:space-between; gap:10px;
      margin-bottom:8px;
    }
    .ctrlHead .name{ font-weight:700; font-size:13.5px; }
    .ctrlHead .value{
      font-variant-numeric: tabular-nums;
      color: var(--muted);
      font-size:13px;
      white-space:nowrap;
    }
    .hint{
      margin-top:6px;
      color:var(--muted);
      font-size:12.5px;
      line-height:1.35;
    }

    /* Bigger sliders */
    input[type="range"]{
      width:100%;
      height: 22px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      margin: 2px 0 0;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(37,99,235,.25), rgba(37,99,235,.10));
      border: 1px solid rgba(15,23,42,.12);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 20px;
      height: 20px;
      margin-top: -6px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid white;
      box-shadow: 0 3px 10px rgba(15,23,42,.18);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track{
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(37,99,235,.25), rgba(37,99,235,.10));
      border: 1px solid rgba(15,23,42,.12);
    }
    input[type="range"]::-moz-range-thumb{
      width: 20px; height: 20px; border-radius: 50%;
      background: var(--accent);
      border: 2px solid white;
      box-shadow: 0 3px 10px rgba(15,23,42,.18);
      cursor:pointer;
    }

    select{
      width:100%;
      font-size:13.5px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(15,23,42,.14);
      background:#fff;
    }

    .readout{
      margin-top:10px;
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .readout b{ color:var(--text); }
    .code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: rgba(15,23,42,.05);
      border:1px solid rgba(15,23,42,.10);
      padding:2px 6px;
      border-radius:8px;
      color: rgba(15,23,42,.85);
      white-space:nowrap;
    }

    .legendRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 12.5px;
    }
    .bar{
      height:10px; width:180px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.12);
      overflow:hidden;
      background:
        linear-gradient(90deg,
          rgb(255,50,50),
          rgb(255,220,50),
          rgb(50,220,50),
          rgb(50,220,255),
          rgb(50,50,255),
          rgb(255,50,255),
          rgb(255,50,50)
        );
    }
    .barGray{
      height:10px; width:180px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.12);
      background: linear-gradient(90deg, rgba(0,0,0,.07), rgba(0,0,0,.65));
    }
  </style>
</head>

<body>
<div class="wrap">
  <h1>STFT d’une sinusoïde : magnitude + phase (lecture claire de l’évolution de phase)</h1>
  <div class="sub">
    La <b>phase</b> est affichée par <b>couleur</b> (angle dans [-π,π]) et n’est montrée que là où la <b>magnitude</b> est suffisante.
    En bas à droite, on trace la phase du <b>bin k≈f</b> en <b>wrap</b> (gris) et en <b>unwrap</b> (bleu) pour voir la pente.
  </div>

  <div class="grid">
    <div class="card">
      <div class="plots">
        <div>
          <div class="sectionTitle">
            <h2>Magnitude (spectrogramme)</h2>
            <span class="pill">dB relatifs au max (0 dB)</span>
          </div>
          <canvas id="mag"></canvas>
          <div class="legendRow">
            <span>faible</span><span class="barGray" title="magnitude"></span><span>fort</span>
          </div>
        </div>

        <div>
          <div class="sectionTitle">
            <h2>Phase (spectrogramme)</h2>
            <span class="pill">couleur = angle, masqué si trop faible</span>
          </div>
          <canvas id="phs"></canvas>
          <div class="legendRow">
            <span>-π</span><span class="bar" title="phase"></span><span>+π</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="sectionTitle">
        <h2>Paramètres + lecture</h2>
        <span class="pill">bin sélectionné = ligne pointillée</span>
      </div>

      <div class="controls">
        <div class="ctrl">
          <div class="ctrlHead">
            <div class="name">Fréquence f (Hz)</div>
            <div class="value" id="freqVal"></div>
          </div>
          <input id="freq" type="range" min="50" max="1500" step="1" value="440">
          <div class="hint">Change la vitesse à laquelle la phase “tourne” d’une trame à l’autre.</div>
        </div>

        <div class="ctrl">
          <div class="ctrlHead">
            <div class="name">Taille FFT N</div>
            <div class="value" id="nfftVal"></div>
          </div>
          <select id="nfft">
            <option value="256">256</option>
            <option value="512" selected>512</option>
            <option value="1024">1024</option>
          </select>
          <div class="hint">Plus N est grand, meilleure est la résolution fréquentielle (bins plus serrés).</div>
        </div>

        <div class="ctrl">
          <div class="ctrlHead">
            <div class="name">Hop H (échantillons)</div>
            <div class="value" id="hopVal"></div>
          </div>
          <input id="hop" type="range" min="16" max="256" step="16" value="128">
          <div class="hint">Plus H est grand, moins il y a de trames → phase “saute” plus entre trames.</div>
        </div>

        <div class="ctrl">
          <div class="ctrlHead">
            <div class="name">f<sub>s</sub> (Hz)</div>
            <div class="value" id="fsVal"></div>
          </div>
          <select id="fs">
            <option value="8000" selected>8000</option>
            <option value="16000">16000</option>
            <option value="44100">44100</option>
          </select>
          <div class="hint">Affecte l’échelle temps et la position des bins (k = f·N/f<sub>s</sub>).</div>
        </div>

        <div class="ctrl">
          <div class="ctrlHead">
            <div class="name">Durée (s)</div>
            <div class="value" id="durVal"></div>
          </div>
          <input id="dur" type="range" min="0.6" max="2.5" step="0.1" value="1.5">
          <div class="hint">Durée du signal analysé (nombre total de trames).</div>
        </div>

        <div class="sectionTitle" style="margin-top:2px;">
          <h2>Phase au bin k≈f</h2>
          <span class="pill">wrap vs unwrap</span>
        </div>
        <canvas id="phaseLine"></canvas>

        <div class="readout" id="readout"></div>
        <div class="readout">
          Formule utile : <span class="code">Δφ ≈ 2π · f · H / f<sub>s</sub></span> (rad par trame, puis “wrap” modulo 2π).
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const magC = document.getElementById('mag');
  const phsC = document.getElementById('phs');
  const lineC= document.getElementById('phaseLine');

  const freqEl = document.getElementById('freq');
  const nfftEl = document.getElementById('nfft');
  const hopEl  = document.getElementById('hop');
  const fsEl   = document.getElementById('fs');
  const durEl  = document.getElementById('dur');

  const freqVal= document.getElementById('freqVal');
  const nfftVal= document.getElementById('nfftVal');
  const hopVal = document.getElementById('hopVal');
  const fsVal  = document.getElementById('fsVal');
  const durVal = document.getElementById('durVal');
  const readout= document.getElementById('readout');

  const css = getComputedStyle(document.documentElement);
  const GRID = css.getPropertyValue('--grid').trim();
  const MUT  = css.getPropertyValue('--muted').trim();
  const TXT  = css.getPropertyValue('--text').trim();
  const ACC  = css.getPropertyValue('--accent').trim();

  function setupHiDPI(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = canvas.getBoundingClientRect();
    canvas.width  = Math.round(r.width * dpr);
    canvas.height = Math.round(r.height * dpr);
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }

  let magCtx = setupHiDPI(magC);
  let phsCtx = setupHiDPI(phsC);
  let linCtx = setupHiDPI(lineC);

  window.addEventListener('resize', () => {
    magCtx = setupHiDPI(magC);
    phsCtx = setupHiDPI(phsC);
    linCtx = setupHiDPI(lineC);
    recomputeAndDraw();
  });

  const fmt = (n,d=3) => {
    const x = Math.abs(n) < 1e-12 ? 0 : n;
    return x.toFixed(d);
  };

  // ----- FFT radix-2 (in-place) -----
  function bitReversePermutation(re, im){
    const n = re.length;
    let j = 0;
    for (let i=0; i<n; i++){
      if (i < j){
        [re[i], re[j]] = [re[j], re[i]];
        [im[i], im[j]] = [im[j], im[i]];
      }
      let m = n >> 1;
      while (m >= 1 && j >= m){ j -= m; m >>= 1; }
      j += m;
    }
  }

  function fft(re, im){
    const n = re.length;
    bitReversePermutation(re, im);
    for (let len=2; len<=n; len<<=1){
      const ang = -2*Math.PI/len;
      const wlenRe = Math.cos(ang);
      const wlenIm = Math.sin(ang);
      for (let i=0; i<n; i+=len){
        let wRe = 1, wIm = 0;
        for (let j=0; j<len/2; j++){
          const uRe = re[i+j], uIm = im[i+j];
          const vRe = re[i+j+len/2]*wRe - im[i+j+len/2]*wIm;
          const vIm = re[i+j+len/2]*wIm + im[i+j+len/2]*wRe;

          re[i+j] = uRe + vRe;
          im[i+j] = uIm + vIm;
          re[i+j+len/2] = uRe - vRe;
          im[i+j+len/2] = uIm - vIm;

          const nextWRe = wRe*wlenRe - wIm*wlenIm;
          const nextWIm = wRe*wlenIm + wIm*wlenRe;
          wRe = nextWRe; wIm = nextWIm;
        }
      }
    }
  }

  function hann(N){
    const w = new Float32Array(N);
    for (let n=0; n<N; n++) w[n] = 0.5 - 0.5*Math.cos(2*Math.PI*n/(N-1));
    return w;
  }

  function wrapPi(phi){
    phi = ((phi + Math.PI) % (2*Math.PI) + (2*Math.PI)) % (2*Math.PI) - Math.PI;
    return phi;
  }

  function drawGrid(ctx, w, h, step=60){
    ctx.save();
    ctx.strokeStyle = GRID;
    ctx.lineWidth = 1;
    for(let x=0;x<=w;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<=h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();
  }

  function phaseToRGB(phi){
    const hue = ((phi + Math.PI) / (2*Math.PI)) * 360;
    const s = 0.90, l = 0.55;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = hue / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let r1=0,g1=0,b1=0;
    if (0<=hp && hp<1){ r1=c; g1=x; b1=0; }
    else if (1<=hp && hp<2){ r1=x; g1=c; b1=0; }
    else if (2<=hp && hp<3){ r1=0; g1=c; b1=x; }
    else if (3<=hp && hp<4){ r1=0; g1=x; b1=c; }
    else if (4<=hp && hp<5){ r1=x; g1=0; b1=c; }
    else { r1=c; g1=0; b1=x; }
    const m = l - c/2;
    return [Math.round((r1+m)*255), Math.round((g1+m)*255), Math.round((b1+m)*255)];
  }

  function recomputeAndDraw(){
    const fs = Number(fsEl.value);
    const f  = Number(freqEl.value);
    const N  = Number(nfftEl.value);
    let H    = Number(hopEl.value);
    const dur= Number(durEl.value);

    if (H > N) { H = N; hopEl.value = String(N); }

    // labels
    freqVal.textContent = `${fmt(f,0)} Hz`;
    nfftVal.textContent = `N = ${N}`;
    hopVal.textContent  = `H = ${H} échant. (${fmt(1000*H/fs,2)} ms)`;
    fsVal.textContent   = `${fs} Hz`;
    durVal.textContent  = `${fmt(dur,1)} s`;

    // signal
    const L = Math.floor(dur * fs);
    const x = new Float32Array(L);
    for (let n=0; n<L; n++) x[n] = Math.sin(2*Math.PI*f*n/fs);

    const win = hann(N);
    const frames = Math.max(1, Math.floor((L - N) / H) + 1);
    const bins = N/2 + 1;

    const magDB = Array.from({length:frames}, () => new Float32Array(bins));
    const ph    = Array.from({length:frames}, () => new Float32Array(bins));

    let globalMax = -1e30;
    const re = new Float32Array(N);
    const im = new Float32Array(N);

    for (let m=0; m<frames; m++){
      const start = m * H;
      for (let n=0; n<N; n++){
        re[n] = (x[start+n] ?? 0) * win[n];
        im[n] = 0;
      }
      fft(re, im);
      for (let k=0; k<bins; k++){
        const a = Math.hypot(re[k], im[k]) / (N/2);
        const db = 20*Math.log10(a + 1e-12);
        magDB[m][k] = db;
        if (db > globalMax) globalMax = db;
        ph[m][k] = Math.atan2(im[k], re[k]);
      }
    }

    const floorDB = -80;
    for (let m=0; m<frames; m++){
      for (let k=0; k<bins; k++){
        magDB[m][k] = Math.max(floorDB, magDB[m][k] - globalMax); // [floor, 0]
      }
    }

    // bin cible
    const k0 = Math.round((f / fs) * N);
    const k = Math.max(0, Math.min(bins-1, k0));
    const fBin = k * fs / N;

    const phaseWrapped = new Float32Array(frames);
    const phaseUnwrap  = new Float32Array(frames);
    for (let m=0; m<frames; m++) phaseWrapped[m] = ph[m][k];

    phaseUnwrap[0] = phaseWrapped[0];
    for (let m=1; m<frames; m++){
      let d = phaseWrapped[m] - phaseWrapped[m-1];
      d = wrapPi(d);
      phaseUnwrap[m] = phaseUnwrap[m-1] + d;
    }

    const dphiTheo = 2*Math.PI * f * H / fs;
    const dphiTheoWrap = wrapPi(dphiTheo);

    const df = fs / N;
    const totalTime = (frames-1)*H/fs;

    readout.innerHTML = `
      <div><b>Résolution fréquentielle :</b> Δf = f<sub>s</sub>/N = <b>${fmt(df,3)}</b> Hz</div>
      <div><b>Bin sélectionné :</b> k = <b>${k}</b> ⇒ f<sub>bin</sub> = <b>${fmt(fBin,2)}</b> Hz (cible f=${fmt(f,0)} Hz)</div>
      <div><b>Δφ théorique par trame :</b> <span class="code">2π f H / f<sub>s</sub></span> = <b>${fmt(dphiTheo,3)}</b> rad (wrap: <b>${fmt(dphiTheoWrap,3)}</b>)</div>
      <div><b>Temps total analysé :</b> <b>${fmt(totalTime,3)}</b> s — trames : <b>${frames}</b></div>
      <div style="margin-top:6px;">Conseil : choisis une fréquence qui n’est <i>pas</i> exactement sur un bin (f ≠ k·Δf) pour voir la phase “dériver” différemment.</div>
    `;

    drawSpectrogramMagnitude(magCtx, magC, magDB, floorDB);
    drawSpectrogramPhase(phsCtx, phsC, ph, magDB, -35);
    drawPhaseLine(linCtx, lineC, phaseWrapped, phaseUnwrap, frames, H, fs, k, fBin);
    drawBinMarker(magCtx, magC, k, bins);
    drawBinMarker(phsCtx, phsC, k, bins);
  }

  function drawSpectrogramMagnitude(ctx, canvas, magDB, floorDB){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);
    drawGrid(ctx,w,h,60);

    const frames = magDB.length;
    const bins = magDB[0].length;
    const pad = {L:52, R:12, T:16, B:26};
    const x0=pad.L, y0=pad.T, pw=w-pad.L-pad.R, ph=h-pad.T-pad.B;

    // axes
    ctx.save();
    ctx.strokeStyle = 'rgba(15,23,42,0.25)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y0+ph);
    ctx.moveTo(x0, y0+ph); ctx.lineTo(x0+pw, y0+ph);
    ctx.stroke();
    ctx.restore();

    const img = ctx.createImageData(Math.floor(pw), Math.floor(ph));
    const data = img.data;

    for (let yi=0; yi<img.height; yi++){
      const k = Math.round((1 - yi/(img.height-1)) * (bins-1));
      for (let xi=0; xi<img.width; xi++){
        const m = Math.round((xi/(img.width-1)) * (frames-1));
        const db = magDB[m][k];                 // [floorDB, 0]
        const t = (db - floorDB) / (0 - floorDB); // 0..1
        const g = Math.round(255 * (0.08 + 0.92*t));
        const idx = (yi*img.width + xi)*4;
        data[idx+0]=g; data[idx+1]=g; data[idx+2]=g; data[idx+3]=255;
      }
    }
    ctx.putImageData(img, x0, y0);

    ctx.save();
    ctx.fillStyle = MUT;
    ctx.font = '12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('freq ↑', 10, y0+12);
    ctx.fillText('temps →', x0+pw-62, y0+ph+20);
    ctx.restore();
  }

  function drawSpectrogramPhase(ctx, canvas, phase, magDB, maskBelowDb){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);
    drawGrid(ctx,w,h,60);

    const frames = phase.length;
    const bins = phase[0].length;
    const pad = {L:52, R:12, T:16, B:26};
    const x0=pad.L, y0=pad.T, pw=w-pad.L-pad.R, ph=h-pad.T-pad.B;

    ctx.save();
    ctx.strokeStyle = 'rgba(15,23,42,0.25)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y0+ph);
    ctx.moveTo(x0, y0+ph); ctx.lineTo(x0+pw, y0+ph);
    ctx.stroke();
    ctx.restore();

    const img = ctx.createImageData(Math.floor(pw), Math.floor(ph));
    const data = img.data;

    for (let yi=0; yi<img.height; yi++){
      const k = Math.round((1 - yi/(img.height-1)) * (bins-1));
      for (let xi=0; xi<img.width; xi++){
        const m = Math.round((xi/(img.width-1)) * (frames-1));
        const db = magDB[m][k];
        const idx = (yi*img.width + xi)*4;

        if (db < maskBelowDb){
          data[idx+0]=235; data[idx+1]=237; data[idx+2]=241; data[idx+3]=255;
        } else {
          const [r,g,b] = phaseToRGB(phase[m][k]);
          data[idx+0]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=255;
        }
      }
    }
    ctx.putImageData(img, x0, y0);

    ctx.save();
    ctx.fillStyle = MUT;
    ctx.font = '12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('freq ↑', 10, y0+12);
    ctx.fillText('temps →', x0+pw-62, y0+ph+20);
    ctx.restore();
  }

  function drawBinMarker(ctx, canvas, k, bins){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const pad = {L:52, R:12, T:16, B:26};
    const x0=pad.L, y0=pad.T, pw=w-pad.L-pad.R, ph=h-pad.T-pad.B;
    const y = y0 + (1 - k/(bins-1)) * ph;

    ctx.save();
    ctx.strokeStyle = 'rgba(37,99,235,0.90)';
    ctx.lineWidth = 2.2;
    ctx.setLineDash([7,6]);
    ctx.beginPath();
    ctx.moveTo(x0, y);
    ctx.lineTo(x0+pw, y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawPhaseLine(ctx, canvas, phWrap, phUnwrap, frames, hop, fs, k, fBin){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);
    drawGrid(ctx,w,h,60);

    const pad = {L:58, R:14, T:18, B:30};
    const x0=pad.L, y0=pad.T, pw=w-pad.L-pad.R, ph=h-pad.T-pad.B;

    // axes
    ctx.save();
    ctx.strokeStyle='rgba(15,23,42,0.25)';
    ctx.lineWidth=1.5;
    ctx.beginPath();
    ctx.moveTo(x0,y0); ctx.lineTo(x0,y0+ph);
    ctx.moveTo(x0,y0+ph); ctx.lineTo(x0+pw,y0+ph);
    ctx.stroke();
    ctx.restore();

    const X = (m) => x0 + (m/Math.max(1,frames-1))*pw;

    // wrapped y: [-π,π]
    const Yw = (phi) => y0 + (1 - (phi + Math.PI)/(2*Math.PI))*ph;

    // wrapped curve (gris)
    ctx.save();
    ctx.strokeStyle = 'rgba(15,23,42,0.55)';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    for (let m=0; m<frames; m++){
      const x = X(m), y = Yw(phWrap[m]);
      if (m===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    // unwrap curve (bleu) — remappé verticalement sur sa plage
    let minU=+1e30, maxU=-1e30;
    for (let m=0; m<frames; m++){ minU=Math.min(minU, phUnwrap[m]); maxU=Math.max(maxU, phUnwrap[m]); }
    const span = Math.max(1e-6, maxU-minU);
    const Yu = (phi)=> y0 + (1 - (phi - minU)/span)*ph;

    ctx.save();
    ctx.strokeStyle = ACC;
    ctx.lineWidth = 2.8;
    ctx.beginPath();
    for (let m=0; m<frames; m++){
      const x = X(m), y = Yu(phUnwrap[m]);
      if (m===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    // labels
    const totalTime = (frames-1)*hop/fs;
    ctx.save();
    ctx.fillStyle = 'rgba(15,23,42,0.78)';
    ctx.font = '12.8px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(`k=${k} (f_bin=${fmt(fBin,2)} Hz) — phase wrap (gris) vs unwrap (bleu)`, x0+6, y0-4);

    ctx.fillStyle = MUT;
    ctx.font = '12.5px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('temps →', x0+pw-55, y0+ph+20);
    ctx.fillText('0 s', x0-10, y0+ph+20);
    ctx.fillText(`${fmt(totalTime/2,3)} s`, x0+pw/2-20, y0+ph+20);
    ctx.fillText(`${fmt(totalTime,3)} s`, x0+pw-28, y0+ph+20);
    ctx.restore();
  }

  function onAnyChange(){
    const N = Number(nfftEl.value);
    const H = Number(hopEl.value);
    if (H > N) hopEl.value = String(N);
    recomputeAndDraw();
  }

  freqEl.addEventListener('input', onAnyChange);
  nfftEl.addEventListener('change', onAnyChange);
  hopEl.addEventListener('input', onAnyChange);
  fsEl.addEventListener('change', onAnyChange);
  durEl.addEventListener('input', onAnyChange);

  recomputeAndDraw();
})();
</script>
</body>
</html>