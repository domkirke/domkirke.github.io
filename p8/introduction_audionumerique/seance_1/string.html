<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Corde vibrante (mode sinusoïdal simple) + Oscilloscope + Son</title>
  <style>
    :root{
      --bg:#ffffff; --panel:#f6f7f9; --ink:#111827; --muted:#6b7280;
      --grid:#e5e7eb; --trace:#2563eb; --accent:#0ea5e9;
    }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink); }
    .wrap{ max-width:980px; margin:18px auto; padding:0 14px 18px; }
    .card{ background:var(--panel); border:1px solid var(--grid); border-radius:12px; padding:12px; }
    .row{ display:grid; grid-template-columns:1fr; gap:12px; }
    .controls{
      display:grid;
      grid-template-columns: repeat(4, minmax(170px, 1fr));
      gap:10px; align-items:end;
    }
    label{ display:grid; gap:6px; font-size:13px; color:var(--muted); }
    input[type="range"]{ width:100%; }
    .val{ font-variant-numeric:tabular-nums; color:var(--ink); font-size:13px; }
    .buttons{ display:flex; gap:10px; justify-content:flex-end; align-items:center; flex-wrap:wrap; }
    button{
      border:1px solid var(--grid); background:#fff; color:var(--ink);
      padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:600;
    }
    button.primary{ border-color: color-mix(in srgb, var(--accent) 35%, var(--grid)); background: color-mix(in srgb, var(--accent) 12%, #fff); }
    button.soundOn{ border-color: color-mix(in srgb, #16a34a 35%, var(--grid)); background: color-mix(in srgb, #16a34a 12%, #fff); }
    .canv{ width:100%; height:260px; background:#fff; border-radius:10px; border:1px solid var(--grid); display:block; }
    .scope{ height:220px; }
    .legend{ display:flex; gap:14px; justify-content:space-between; align-items:baseline; margin-top:8px; color:var(--muted); font-size:13px; }
    .mono{ font-variant-numeric:tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <div class="card">
        <div class="controls">
          <label>
            Longueur L (m)
            <input id="L" type="range" min="0.30" max="1.20" value="0.65" step="0.01">
            <div class="val"><span id="LVal" class="mono"></span></div>
          </label>

          <label>
            Vitesse d’onde c (m/s)
            <input id="c" type="range" min="40" max="300" value="130" step="1">
            <div class="val"><span id="cVal" class="mono"></span></div>
          </label>

          <label>
            Mode n (harmonique)
            <input id="n" type="range" min="1" max="8" value="1" step="1">
            <div class="val"><span id="nVal" class="mono"></span></div>
          </label>

          <label>
            Amplitude A (mm)
            <input id="A" type="range" min="1" max="20" value="8" step="1">
            <div class="val"><span id="AVal" class="mono"></span></div>
          </label>

          <label>
            Phase φ (rad)
            <input id="phi" type="range" min="0" max="6.283" value="0" step="0.01">
            <div class="val"><span id="phiVal" class="mono"></span></div>
          </label>

          <label>
            Point “micro” q = x/L
            <input id="q" type="range" min="0.05" max="0.95" value="0.80" step="0.01">
            <div class="val"><span id="qVal" class="mono"></span></div>
          </label>

          <div class="buttons">
            <button id="reset" class="primary">Reset (t=0)</button>
            <button id="toggle">Pause</button>
            <button id="sound">Son: OFF</button>
          </div>
        </div>

        <div class="legend">
          <div class="mono" id="eqn"></div>
          <div>
            <span>fₙ :</span> <span id="fnVal" class="mono"></span>
            <span style="margin-left:10px;">ωₙ :</span> <span id="wnVal" class="mono"></span>
          </div>
        </div>
      </div>

      <div class="card">
        <canvas id="sim" class="canv"></canvas>
      </div>

      <div class="card">
        <canvas id="scope" class="canv scope"></canvas>
        <div class="legend">
          <div>Oscilloscope : <span class="mono">y(qL, t)</span></div>
          <div><span>Fenêtre :</span> <span id="tWindowVal" class="mono"></span></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const sim = document.getElementById('sim');
  const scope = document.getElementById('scope');
  const ctx = sim.getContext('2d');
  const sctx = scope.getContext('2d');

  const els = {
    L: document.getElementById('L'),
    c: document.getElementById('c'),
    n: document.getElementById('n'),
    A: document.getElementById('A'),
    phi: document.getElementById('phi'),
    q: document.getElementById('q'),
  };

  const ui = {
    LVal: document.getElementById('LVal'),
    cVal: document.getElementById('cVal'),
    nVal: document.getElementById('nVal'),
    AVal: document.getElementById('AVal'),
    phiVal: document.getElementById('phiVal'),
    qVal: document.getElementById('qVal'),
    fnVal: document.getElementById('fnVal'),
    wnVal: document.getElementById('wnVal'),
    eqn: document.getElementById('eqn'),
    tWindowVal: document.getElementById('tWindowVal'),
  };

  const resetBtn = document.getElementById('reset');
  const toggleBtn = document.getElementById('toggle');
  const soundBtn = document.getElementById('sound');

  let running = true;
  let t = 0;
  let last = performance.now();

  // Oscilloscope
  let trace = [];
  const timeWindow = 0.08; // s
  ui.tWindowVal.textContent = `${timeWindow.toFixed(2)} s`;

  // Dessin
  const XPTS = 360;
  let dprSim = 1, dprScope = 1;

  function resizeCanvas(c) {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = c.getBoundingClientRect();
    c.width = Math.round(rect.width * dpr);
    c.height = Math.round(rect.height * dpr);
    return dpr;
  }

  function doResize() {
    dprSim = resizeCanvas(sim);
    dprScope = resizeCanvas(scope);
    trace = new Array(scope.width).fill(scope.height / 2);
  }
  window.addEventListener('resize', doResize);
  doResize();

  function params() {
    const L = parseFloat(els.L.value);
    const c = parseFloat(els.c.value);
    const n = parseInt(els.n.value, 10);
    const A = parseFloat(els.A.value) / 1000; // mm -> m
    const phi = parseFloat(els.phi.value);
    const q = parseFloat(els.q.value);

    const fn = (n * c) / (2 * L);
    const wn = 2 * Math.PI * fn;
    return { L, c, n, A, phi, q, fn, wn };
  }

  function updateUI() {
    const { L, c, n, A, phi, q, fn, wn } = params();
    ui.LVal.textContent = L.toFixed(2);
    ui.cVal.textContent = c.toFixed(0);
    ui.nVal.textContent = String(n);
    ui.AVal.textContent = (A * 1000).toFixed(0);
    ui.phiVal.textContent = phi.toFixed(2);
    ui.qVal.textContent = q.toFixed(2);
    ui.fnVal.textContent = `${fn.toFixed(1)} Hz`;
    ui.wnVal.textContent = `${wn.toFixed(1)} rad/s`;
    ui.eqn.textContent = `y(x,t) = A·sin(${n}πx/L)·cos(ωₙ t + φ)`;
  }

  function resetTime() {
    t = 0;
    last = performance.now();
    trace = new Array(scope.width).fill(scope.height / 2);
    // Note : l'audio reste continu (sinus). Si tu veux recaler la phase audio,
    // on peut redémarrer l'oscillateur ici.
  }

  function drawString() {
    const W = sim.width, H = sim.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,H);

    const margin = 28 * dprSim;
    const x0 = margin, x1 = W - margin;
    const yMid = H * 0.55;

    // extrémités fixées
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2 * dprSim;
    ctx.beginPath();
    ctx.moveTo(x0, yMid - 55*dprSim); ctx.lineTo(x0, yMid + 55*dprSim);
    ctx.moveTo(x1, yMid - 55*dprSim); ctx.lineTo(x1, yMid + 55*dprSim);
    ctx.stroke();

    // ligne centrale
    ctx.strokeStyle = '#e5e7eb';
    ctx.setLineDash([6*dprSim,6*dprSim]);
    ctx.beginPath(); ctx.moveTo(x0, yMid); ctx.lineTo(x1, yMid); ctx.stroke();
    ctx.setLineDash([]);

    const { L, n, A, phi, wn, q } = params();

    // corde
    const ampPx = H * 0.35;
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2.2 * dprSim;
    ctx.beginPath();
    for (let i = 0; i < XPTS; i++) {
      const u = i / (XPTS - 1);
      const x = x0 + u * (x1 - x0);
      const xx = u * L;

      const yMeters = A * Math.sin(n * Math.PI * xx / L) * Math.cos(wn * t + phi);
      const y = yMid - (yMeters / Math.max(1e-6, 1.2*A)) * ampPx;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // point micro
    const uQ = q;
    const xQ = x0 + uQ * (x1 - x0);
    const xMetersQ = uQ * L;
    const yMetersQ = A * Math.sin(n * Math.PI * xMetersQ / L) * Math.cos(wn * t + phi);
    const yQ = yMid - (yMetersQ / Math.max(1e-6, 1.2*A)) * ampPx;

    ctx.fillStyle = '#2563eb';
    ctx.beginPath();
    ctx.arc(xQ, yQ, 4.2*dprSim, 0, Math.PI*2);
    ctx.fill();
  }

  function drawGridScope() {
    const W = scope.width, H = scope.height;
    sctx.clearRect(0,0,W,H);
    sctx.fillStyle = '#ffffff';
    sctx.fillRect(0,0,W,H);

    sctx.strokeStyle = '#e5e7eb';
    sctx.lineWidth = 1*dprScope;
    const stepX = Math.round(W/10), stepY = Math.round(H/6);
    for (let x=0; x<=W; x+=stepX){ sctx.beginPath(); sctx.moveTo(x,0); sctx.lineTo(x,H); sctx.stroke(); }
    for (let y=0; y<=H; y+=stepY){ sctx.beginPath(); sctx.moveTo(0,y); sctx.lineTo(W,y); sctx.stroke(); }

    sctx.strokeStyle = '#cbd5e1';
    sctx.lineWidth = 2*dprScope;
    sctx.beginPath(); sctx.moveTo(0,H/2); sctx.lineTo(W,H/2); sctx.stroke();
  }

  function pushScopeSample(yMeters) {
    const W = scope.width, H = scope.height;
    const { A } = params();
    const Aref = Math.max(1e-6, 1.2*A);
    const yPix = (H/2) - (yMeters / Aref) * (H * 0.40);

    trace.push(yPix);
    if (trace.length > W) trace.shift();

    drawGridScope();
    sctx.strokeStyle = '#2563eb';
    sctx.lineWidth = 2.2*dprScope;
    sctx.beginPath();
    for (let i=0; i<trace.length; i++){
      if (i===0) sctx.moveTo(i, trace[i]);
      else sctx.lineTo(i, trace[i]);
    }
    sctx.stroke();

    sctx.fillStyle = '#2563eb';
    sctx.beginPath();
    sctx.arc(trace.length-1, trace[trace.length-1], 3.2*dprScope, 0, Math.PI*2);
    sctx.fill();
  }

  // ------------------ AUDIO (sortie son ON/OFF) ------------------
  let audio = {
    ctx: null,
    osc: null,
    gain: null,
    on: false,
  };

  function desiredAudioGain() {
    // Gain audio "pédagogique" (pas une conversion physique).
    // On utilise A (mm) + le facteur spatial au point q : sin(nπq).
    const { A, n, q } = params();
    const spatial = Math.abs(Math.sin(n * Math.PI * q)); // 0..1
    // A typiquement 1..20 mm -> 0.001..0.02 m
    // On mappe vers un gain modéré:
    const base = Math.min(1, (A / 0.02)); // ~0..1
    return 0.15 * base * spatial;         // plafond ~0.15
  }

  function ensureAudioGraph() {
    if (!audio.ctx) {
      audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (!audio.gain) {
      audio.gain = audio.ctx.createGain();
      audio.gain.gain.value = 0;
      audio.gain.connect(audio.ctx.destination);
    }
    if (!audio.osc) {
      audio.osc = audio.ctx.createOscillator();
      audio.osc.type = 'sine';
      audio.osc.connect(audio.gain);
      audio.osc.start();
    }
  }

  async function setSound(on) {
    if (on) {
      ensureAudioGraph();
      await audio.ctx.resume(); // nécessaire sur beaucoup de navigateurs (geste utilisateur)
      audio.on = true;
      soundBtn.textContent = 'Son: ON';
      soundBtn.classList.add('soundOn');
      applyAudioParams(true);
    } else {
      audio.on = false;
      soundBtn.textContent = 'Son: OFF';
      soundBtn.classList.remove('soundOn');
      if (audio.gain && audio.ctx) {
        const now = audio.ctx.currentTime;
        audio.gain.gain.cancelScheduledValues(now);
        audio.gain.gain.setTargetAtTime(0.0, now, 0.015); // fade out
      }
    }
  }

  function applyAudioParams(quick = false) {
    if (!audio.on || !audio.ctx || !audio.osc || !audio.gain) return;
    const { fn } = params();
    const now = audio.ctx.currentTime;

    // fréquence
    audio.osc.frequency.setValueAtTime(fn, now);

    // amplitude (gain) avec petit lissage pour éviter les clics
    const g = desiredAudioGain();
    audio.gain.gain.cancelScheduledValues(now);
    if (quick) audio.gain.gain.setValueAtTime(g, now);
    else audio.gain.gain.setTargetAtTime(g, now, 0.02);
  }
  // -------------------------------------------------------------

  function step(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if (running) t += dt;

    drawString();

    const { L, n, A, phi, wn, q } = params();
    const xq = q * L;
    const yq = A * Math.sin(n * Math.PI * xq / L) * Math.cos(wn * t + phi);
    pushScopeSample(yq);

    requestAnimationFrame(step);
  }

  function onParamChange() {
    updateUI();
    applyAudioParams(false);
  }

  Object.values(els).forEach(el => el.addEventListener('input', onParamChange));

  resetBtn.addEventListener('click', resetTime);
  toggleBtn.addEventListener('click', () => {
    running = !running;
    toggleBtn.textContent = running ? 'Pause' : 'Play';
  });

  soundBtn.addEventListener('click', async () => {
    await setSound(!audio.on);
  });

  updateUI();
  resetTime();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>