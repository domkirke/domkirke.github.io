<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Masse-Ressort + Oscilloscope</title>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #f6f7f9;
      --ink: #111827;
      --muted: #6b7280;
      --grid: #e5e7eb;
      --trace: #2563eb;
      --spring: #111827;
      --mass: #111827;
      --accent: #0ea5e9;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
    }
    .wrap {
      max-width: 980px;
      margin: 18px auto;
      padding: 0 14px 18px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 12px;
      padding: 12px;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(140px, 1fr));
      gap: 10px;
      align-items: end;
    }
    label {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    input[type="range"] { width: 100%; }
    .val {
      font-variant-numeric: tabular-nums;
      color: var(--ink);
      font-size: 13px;
    }
    .buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      align-items: center;
    }
    button {
      border: 1px solid var(--grid);
      background: #fff;
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }
    button.primary {
      border-color: color-mix(in srgb, var(--accent) 35%, var(--grid));
      background: color-mix(in srgb, var(--accent) 12%, #fff);
    }
    .canv {
      width: 100%;
      height: 260px;
      background: #fff;
      border-radius: 10px;
      border: 1px solid var(--grid);
      display: block;
    }
    .scope {
      height: 220px;
    }
    .legend {
      display: flex;
      gap: 14px;
      justify-content: space-between;
      align-items: baseline;
      margin-top: 8px;
      color: var(--muted);
      font-size: 13px;
    }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <div class="card">
        <div class="controls">
          <label>
            Masse m (kg)
            <input id="m" type="range" min="0.2" max="5.0" value="1.0" step="0.1">
            <div class="val"><span id="mVal" class="mono"></span></div>
          </label>
          <label>
            Raideur k (N/m)
            <input id="k" type="range" min="1" max="200" value="40" step="1">
            <div class="val"><span id="kVal" class="mono"></span></div>
          </label>
          <label>
            Amplitude A (m)
            <input id="A" type="range" min="0.01" max="0.30" value="0.12" step="0.01">
            <div class="val"><span id="AVal" class="mono"></span></div>
          </label>
          <div class="buttons">
            <button id="reset" class="primary">Reset</button>
            <button id="toggle">Pause</button>
          </div>
        </div>

        <div class="legend">
          <div>
            Oscillation libre : <span class="mono">x(t) = A cos(ωt)</span>, avec <span class="mono">ω = √(k/m)</span>
          </div>
          <div>
            <span>Fréquence : </span><span id="fVal" class="mono"></span>
          </div>
        </div>
      </div>

      <div class="card">
        <canvas id="sim" class="canv"></canvas>
      </div>

      <div class="card">
        <canvas id="scope" class="canv scope"></canvas>
        <div class="legend">
          <div>Oscilloscope : déplacement <span class="mono">x(t)</span> (défilement)</div>
          <div><span>Temps (fenêtre) :</span> <span id="tWindowVal" class="mono"></span></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const sim = document.getElementById('sim');
  const scope = document.getElementById('scope');
  const ctx = sim.getContext('2d');
  const sctx = scope.getContext('2d');

  const mEl = document.getElementById('m');
  const kEl = document.getElementById('k');
  const AEl = document.getElementById('A');

  const mVal = document.getElementById('mVal');
  const kVal = document.getElementById('kVal');
  const AVal = document.getElementById('AVal');
  const fVal = document.getElementById('fVal');
  const tWindowVal = document.getElementById('tWindowVal');

  const resetBtn = document.getElementById('reset');
  const toggleBtn = document.getElementById('toggle');

  let running = true;

  // État physique
  let t = 0;              // temps (s)
  let last = performance.now();

  // Oscilloscope (buffer défilant)
  let trace = [];
  let timeWindow = 6.0;   // secondes visibles dans la largeur du scope

  function resizeCanvas(c, hCss) {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = c.getBoundingClientRect();
    c.width = Math.round(rect.width * dpr);
    c.height = Math.round((hCss ?? rect.height) * dpr);
    return dpr;
  }

  let dprSim = 1, dprScope = 1;

  function doResize() {
    dprSim = resizeCanvas(sim);
    dprScope = resizeCanvas(scope);
    // Réinitialiser le buffer pour correspondre à la nouvelle largeur
    trace = new Array(scope.width).fill(0);
  }

  window.addEventListener('resize', doResize);
  doResize();

  function params() {
    const m = parseFloat(mEl.value);
    const k = parseFloat(kEl.value);
    const A = parseFloat(AEl.value);
    const w = Math.sqrt(k / m);      // rad/s
    const f = w / (2 * Math.PI);     // Hz
    return { m, k, A, w, f };
  }

  function updateUI() {
    const { m, k, A, f } = params();
    mVal.textContent = m.toFixed(1);
    kVal.textContent = k.toFixed(0);
    AVal.textContent = A.toFixed(2);
    fVal.textContent = `${f.toFixed(2)} Hz`;
    // fenêtre en secondes (dépend un peu du canvas, mais on l’affiche fixe)
    tWindowVal.textContent = `${timeWindow.toFixed(1)} s`;
  }

  function reset() {
    t = 0;
    last = performance.now();
    trace = new Array(scope.width).fill(0);
  }

  // Dessin ressort en zig-zag
  function drawSpring(ctx, x0, y0, x1, y1, coils = 12, amp = 10) {
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    const dx = x1 - x0;
    const dy = y1 - y0;

    for (let i = 1; i < coils; i++) {
      const u = i / coils;
      const x = x0 + dx * u;
      const y = y0 + dy * u + (i % 2 === 0 ? -amp : amp);
      ctx.lineTo(x, y);
    }
    ctx.lineTo(x1, y1);
    ctx.stroke();
  }

  function drawSim(xMeters) {
    const W = sim.width, H = sim.height;
    ctx.clearRect(0, 0, W, H);

    // Fond blanc
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, W, H);

    // Repère
    const margin = 28 * dprSim;
    const yMid = H * 0.55;
    const leftWallX = margin;
    const eqX = margin + (W - 2 * margin) * 0.55;

    // Conversion m -> px (échelle visuelle)
    const pxPerMeter = (W - 2 * margin) * 0.9; // 1 m occuperait presque la largeur
    const x = eqX + xMeters * pxPerMeter;

    // Mur
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2 * dprSim;
    ctx.beginPath();
    ctx.moveTo(leftWallX, yMid - 55 * dprSim);
    ctx.lineTo(leftWallX, yMid + 55 * dprSim);
    ctx.stroke();

    // Hachures du mur
    ctx.lineWidth = 1 * dprSim;
    for (let yy = yMid - 55 * dprSim; yy <= yMid + 55 * dprSim; yy += 10 * dprSim) {
      ctx.beginPath();
      ctx.moveTo(leftWallX - 10 * dprSim, yy);
      ctx.lineTo(leftWallX, yy + 6 * dprSim);
      ctx.stroke();
    }

    // Ligne d’équilibre (pointillée)
    ctx.strokeStyle = '#e5e7eb';
    ctx.setLineDash([6 * dprSim, 6 * dprSim]);
    ctx.lineWidth = 2 * dprSim;
    ctx.beginPath();
    ctx.moveTo(eqX, yMid - 90 * dprSim);
    ctx.lineTo(eqX, yMid + 90 * dprSim);
    ctx.stroke();
    ctx.setLineDash([]);

    // Ressort
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 2.5 * dprSim;
    drawSpring(ctx, leftWallX, yMid, x - 28 * dprSim, yMid, 14, 10 * dprSim);

    // Masse (bloc)
    const mw = 56 * dprSim, mh = 48 * dprSim;
    ctx.fillStyle = '#111827';
    ctx.fillRect(x - mw/2, yMid - mh/2, mw, mh);

    // Petit highlight
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(x - mw/2 + 6*dprSim, yMid - mh/2 + 6*dprSim, mw*0.35, mh*0.25);

    // Texte x(t)
    ctx.fillStyle = '#6b7280';
    ctx.font = `${12 * dprSim}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
    const label = `x = ${xMeters.toFixed(3)} m`;
    ctx.fillText(label, margin, margin + 8 * dprSim);
  }

  function drawGridScope() {
    const W = scope.width, H = scope.height;
    sctx.clearRect(0, 0, W, H);

    // fond
    sctx.fillStyle = '#ffffff';
    sctx.fillRect(0, 0, W, H);

    // grille
    sctx.strokeStyle = '#e5e7eb';
    sctx.lineWidth = 1 * dprScope;

    const stepX = Math.round(W / 10);
    const stepY = Math.round(H / 6);

    for (let x = 0; x <= W; x += stepX) {
      sctx.beginPath();
      sctx.moveTo(x, 0);
      sctx.lineTo(x, H);
      sctx.stroke();
    }
    for (let y = 0; y <= H; y += stepY) {
      sctx.beginPath();
      sctx.moveTo(0, y);
      sctx.lineTo(W, y);
      sctx.stroke();
    }

    // axe central
    sctx.strokeStyle = '#cbd5e1';
    sctx.lineWidth = 2 * dprScope;
    sctx.beginPath();
    sctx.moveTo(0, H/2);
    sctx.lineTo(W, H/2);
    sctx.stroke();
  }

  function drawTrace(xMeters) {
    const W = scope.width, H = scope.height;

    // normalisation: on mappe +/-Amax vers hauteur
    const { A } = params();
    const Amax = Math.max(0.01, A); // éviter division par 0
    const y = (H/2) - (xMeters / Amax) * (H * 0.40);

    // buffer: défilement vers la gauche, nouvel échantillon à droite
    trace.push(y);
    if (trace.length > W) trace.shift();

    // dessin
    drawGridScope();

    sctx.strokeStyle = '#2563eb';
    sctx.lineWidth = 2.2 * dprScope;
    sctx.beginPath();
    for (let i = 0; i < trace.length; i++) {
      const yy = trace[i];
      if (i === 0) sctx.moveTo(i, yy);
      else sctx.lineTo(i, yy);
    }
    sctx.stroke();

    // petit point "tête de lecture"
    sctx.fillStyle = '#2563eb';
    sctx.beginPath();
    sctx.arc(trace.length - 1, trace[trace.length - 1], 3.2 * dprScope, 0, Math.PI*2);
    sctx.fill();
  }

  function step(now) {
    const dt = Math.min(0.033, (now - last) / 1000); // clamp ~30ms
    last = now;

    if (running) t += dt;

    const { A, w } = params();
    // Oscillation libre non amortie:
    const x = A * Math.cos(w * t);

    drawSim(x);

    // cadence du scope : on veut environ W points sur timeWindow secondes
    // => on avance le buffer "virtuellement" à chaque frame; ici on pousse 1 point/frame,
    // mais on ajuste timeWindow affichée selon FPS réel.
    // Pour rester simple: on pousse 1 point/frame et on affiche timeWindow fixe.
    drawTrace(x);

    requestAnimationFrame(step);
  }

  function onParamChange() {
    updateUI();
    // Option: redémarrer pour éviter les sauts de phase visuels
    reset();
  }

  mEl.addEventListener('input', onParamChange);
  kEl.addEventListener('input', onParamChange);
  AEl.addEventListener('input', onParamChange);

  resetBtn.addEventListener('click', () => reset());
  toggleBtn.addEventListener('click', () => {
    running = !running;
    toggleBtn.textContent = running ? 'Pause' : 'Play';
  });

  updateUI();
  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>